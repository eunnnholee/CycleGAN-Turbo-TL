op0_op1: FusedSchedulerNode(SchedulerNode,SchedulerNode)
op0_op1.writes = [MemoryDep('buf0', c0, {c0: 4096}), MemoryDep('buf1', c0, {c0: 4096})]
op0_op1.unmet_dependencies = []
op0_op1.met_dependencies = 
    [   MemoryDep('primals_1', 0, {}),
        MemoryDep('primals_2', 0, {}),
        MemoryDep('primals_3', c0, {c0: 4096}),
        MemoryDep('primals_4', c0, {c0: 4096})]
op0_op1.outputs = [
    buf0: ComputedBuffer
    buf0.layout = FixedLayout('cuda:0', torch.float32, size=[4, 32, 32], stride=[1024, 32, 1])
    buf0.users = [
        NodeUser(node=SchedulerNode(name='op1'), can_inplace=True, is_weak=False),
        NodeUser(node=OUTPUT, can_inplace=False, is_weak=False),
    ]
    buf1: ComputedBuffer
    buf1.layout = FixedLayout('cuda:0', torch.float32, size=[4, 32, 32], stride=[1024, 32, 1])
    buf1.users = [NodeUser(node=OUTPUT, can_inplace=False, is_weak=False)]
]
op0_op1.snodes[0] =
op0: SchedulerNode(ComputedBuffer)
op0.writes = [MemoryDep('buf0', c0, {c0: 4096})]
op0.unmet_dependencies = []
op0.met_dependencies = 
    [   MemoryDep('primals_2', 0, {}),
        MemoryDep('primals_3', c0, {c0: 4096}),
        MemoryDep('primals_4', c0, {c0: 4096})]
op0.outputs = [
    buf0: ComputedBuffer
    buf0.layout = FixedLayout('cuda:0', torch.float32, size=[4, 32, 32], stride=[1024, 32, 1])
    buf0.users = [
        NodeUser(node=SchedulerNode(name='op1'), can_inplace=True, is_weak=False),
        NodeUser(node=OUTPUT, can_inplace=False, is_weak=False),
    ]
]
op0.group.device = cuda:0
op0.group.iteration = (4096, 1)
op0.sizes = ([4096], [])
primals_4_layout = FixedLayout('cuda:0', torch.float32, size=[4, 32, 32], stride=[1024, 32, 1])
primals_2_layout = FixedLayout('cuda:0', torch.float32, size=[], stride=[])
primals_3_layout = FixedLayout('cuda:0', torch.float32, size=[4, 32, 32], stride=[1024, 32, 1])
buf0_layout = FixedLayout('cuda:0', torch.float32, size=[4, 32, 32], stride=[1024, 32, 1])
class op0_loop_body:
    var_ranges = {p0: 4096}
    index0 = p0
    index1 = 0
    def body(self, ops):
        get_index = self.get_index('index0')
        load = ops.load('primals_4', get_index)
        get_index_1 = self.get_index('index1')
        load_1 = ops.load('primals_2', get_index_1)
        constant = ops.constant(1.0, torch.float32)
        sub = ops.sub(constant, load_1)
        sqrt = ops.sqrt(sub)
        get_index_2 = self.get_index('index0')
        load_2 = ops.load('primals_3', get_index_2)
        mul = ops.mul(sqrt, load_2)
        sub_1 = ops.sub(load, mul)
        get_index_3 = self.get_index('index1')
        load_3 = ops.load('primals_2', get_index_3)
        sqrt_1 = ops.sqrt(load_3)
        truediv = ops.truediv(sub_1, sqrt_1)
        get_index_4 = self.get_index('index0')
        store = ops.store('buf0', get_index_4, truediv, None)
        return store
op0_op1.snodes[1] =
op1: SchedulerNode(ComputedBuffer)
op1.writes = [MemoryDep('buf1', c0, {c0: 4096})]
op1.unmet_dependencies = [MemoryDep('buf0', c0, {c0: 4096})]
op1.met_dependencies = 
    [   MemoryDep('primals_1', 0, {}),
        MemoryDep('primals_2', 0, {}),
        MemoryDep('primals_4', c0, {c0: 4096})]
op1.outputs = [
    buf1: ComputedBuffer
    buf1.layout = FixedLayout('cuda:0', torch.float32, size=[4, 32, 32], stride=[1024, 32, 1])
    buf1.users = [NodeUser(node=OUTPUT, can_inplace=False, is_weak=False)]
]
op1.group.device = cuda:0
op1.group.iteration = (4096, 1)
op1.sizes = ([4096], [])
primals_1_layout = FixedLayout('cpu', torch.float32, size=[], stride=[])
primals_2_layout = FixedLayout('cuda:0', torch.float32, size=[], stride=[])
buf0_layout = FixedLayout('cuda:0', torch.float32, size=[4, 32, 32], stride=[1024, 32, 1])
primals_4_layout = FixedLayout('cuda:0', torch.float32, size=[4, 32, 32], stride=[1024, 32, 1])
buf1_layout = FixedLayout('cuda:0', torch.float32, size=[4, 32, 32], stride=[1024, 32, 1])
class op1_loop_body:
    var_ranges = {p0: 4096}
    index0 = 0
    index1 = p0
    def body(self, ops):
        get_index = self.get_index('index0')
        load = ops.load('primals_1', get_index)
        sqrt = ops.sqrt(load)
        get_index_1 = self.get_index('index0')
        load_1 = ops.load('primals_2', get_index_1)
        get_index_2 = self.get_index('index0')
        load_2 = ops.load('primals_1', get_index_2)
        truediv = ops.truediv(load_1, load_2)
        constant = ops.constant(1.0, torch.float32)
        sub = ops.sub(constant, truediv)
        mul = ops.mul(sqrt, sub)
        get_index_3 = self.get_index('index0')
        load_3 = ops.load('primals_2', get_index_3)
        constant_1 = ops.constant(1.0, torch.float32)
        sub_1 = ops.sub(constant_1, load_3)
        truediv_1 = ops.truediv(mul, sub_1)
        get_index_4 = self.get_index('index1')
        load_4 = ops.load('buf0', get_index_4)
        mul_1 = ops.mul(truediv_1, load_4)
        get_index_5 = self.get_index('index0')
        load_5 = ops.load('primals_2', get_index_5)
        get_index_6 = self.get_index('index0')
        load_6 = ops.load('primals_1', get_index_6)
        truediv_2 = ops.truediv(load_5, load_6)
        sqrt_1 = ops.sqrt(truediv_2)
        get_index_7 = self.get_index('index0')
        load_7 = ops.load('primals_1', get_index_7)
        constant_2 = ops.constant(1.0, torch.float32)
        sub_2 = ops.sub(constant_2, load_7)
        mul_2 = ops.mul(sqrt_1, sub_2)
        get_index_8 = self.get_index('index0')
        load_8 = ops.load('primals_2', get_index_8)
        constant_3 = ops.constant(1.0, torch.float32)
        sub_3 = ops.sub(constant_3, load_8)
        truediv_3 = ops.truediv(mul_2, sub_3)
        get_index_9 = self.get_index('index1')
        load_9 = ops.load('primals_4', get_index_9)
        mul_3 = ops.mul(truediv_3, load_9)
        add = ops.add(mul_1, mul_3)
        get_index_10 = self.get_index('index1')
        store = ops.store('buf1', get_index_10, add, None)
        return store


op2: SchedulerNode(ComputedBuffer)
op2.writes = [MemoryDep('buf2', 0, {})]
op2.unmet_dependencies = []
op2.met_dependencies = [MemoryDep('primals_5', 0, {})]
op2.outputs = [
    buf2: ComputedBuffer
    buf2.layout = FixedLayout('cuda:0', torch.bool, size=[], stride=[])
    buf2.users = [NodeUser(node=OUTPUT, can_inplace=False, is_weak=False)]
]
op2.group.device = cuda:0
op2.group.iteration = (1, 1)
op2.sizes = ([], [])
primals_5_layout = FixedLayout('cuda:0', torch.int64, size=[], stride=[])
buf2_layout = FixedLayout('cuda:0', torch.bool, size=[], stride=[])
class op2_loop_body:
    var_ranges = {}
    index0 = 0
    def body(self, ops):
        get_index = self.get_index('index0')
        load = ops.load('primals_5', get_index)
        constant = ops.constant(0, torch.int64)
        gt = ops.gt(load, constant)
        get_index_1 = self.get_index('index0')
        store = ops.store('buf2', get_index_1, gt, None)
        return store


