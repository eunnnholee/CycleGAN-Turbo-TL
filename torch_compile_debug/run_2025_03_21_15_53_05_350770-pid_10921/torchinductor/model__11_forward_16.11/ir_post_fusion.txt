op0: SchedulerNode(ComputedBuffer)
op0.writes = [MemoryDep('buf0', c0, {c0: 4096})]
op0.unmet_dependencies = []
op0.met_dependencies = 
    [   MemoryDep('primals_1', 0, {}),
        MemoryDep('primals_2', c0, {c0: 4096}),
        MemoryDep('primals_3', c0, {c0: 4096})]
op0.outputs = [
    buf0: ComputedBuffer
    buf0.layout = FixedLayout('cuda:0', torch.float32, size=[4, 32, 32], stride=[1024, 32, 1])
    buf0.users = [NodeUser(node=OUTPUT, can_inplace=False, is_weak=False)]
]
op0.group.device = cuda:0
op0.group.iteration = (4096, 1)
op0.sizes = ([4096], [])
primals_3_layout = FixedLayout('cuda:0', torch.float32, size=[4, 32, 32], stride=[1024, 32, 1])
primals_1_layout = FixedLayout('cuda:0', torch.float32, size=[], stride=[])
primals_2_layout = FixedLayout('cuda:0', torch.float32, size=[4, 32, 32], stride=[1024, 32, 1])
buf0_layout = FixedLayout('cuda:0', torch.float32, size=[4, 32, 32], stride=[1024, 32, 1])
class op0_loop_body:
    var_ranges = {p0: 4096}
    index0 = p0
    index1 = 0
    def body(self, ops):
        get_index = self.get_index('index0')
        load = ops.load('primals_3', get_index)
        get_index_1 = self.get_index('index1')
        load_1 = ops.load('primals_1', get_index_1)
        sqrt = ops.sqrt(load_1)
        get_index_2 = self.get_index('index0')
        load_2 = ops.load('primals_2', get_index_2)
        mul = ops.mul(sqrt, load_2)
        add = ops.add(load, mul)
        get_index_3 = self.get_index('index0')
        store = ops.store('buf0', get_index_3, add, None)
        return store


